## linux内存管理

全文以x64，32位系统为例

### 虚拟地址

为了充分利用和管理系统内存资源，linux采用虚拟内存管理技术，利用虚拟技术，让每个进程都拥有4GB互不干涉的虚拟内存地址空间；

进程初始化和分配的都是基于虚拟地址分配的，只有当进程需要实际访问内存资源的时候，才将虚拟地址与物理地址建立映射关系，调入物理内存页；

虚拟内存的优点：
1. 进程内存管理
    + 它有助于进程进行内存管理，用户访问时，需要先访问映射页，操作系统在页上添加各种标识符就可以做到权限控制
    + 由于虚拟内存对程序的欺骗性，程序可以不用考虑大块内存的分配；同时也可以防止用户直接访问物理内存，做一些破坏性的操作
2. 数据共享
    + 进程加载系统库时，总是先分配一块内存，将系统库文件加载进去，如果使用物理地址，则会存在一个库被多次加载，系统也无法区分；而通过虚拟内存，则可直接将后续的进程的虚拟地址直接指向已加载好的物理内存地址
    + 共享内存时，也只用修改虚拟地址的指向即可
3. SWAP
    + 在使用free命令时，可以看到Swap属性，SWAP是系统为进程进行扩容使用到的技术；因为内存是有限的，当所有物理内存都被使用后，系统此时会使用SWAP技术，将内存中暂时不需要的数据转移到磁盘上，将腾出的内存空间拿来给有需要的进程使用；当需要再使用时，重新加载到内存，同时把另一部分没有使用到的数据转移到硬盘上
    + 该技术虽然可以让虚拟内存表面上变多，但是物理内存大小并不会改变，真正存在于内存的数据还是那么多，而且需要重新加载swap到磁盘的数据时，需要时间加载与转移，同时消耗CPU，当swap频繁发生时，会极大的消耗CPU，程序运行速度必然下降；所以，当系统开始使用SWAP时，那么就需要考虑是进程的内存使用不当还是系统硬件能力不足需要进行升级，当然也可以通过设置vm.swappiness=0修改SWAP的值或者直接禁掉(swapoff)

top命令下可以看到VIRT和RES(resident)列，VIRT为分配的虚拟内存，RES为实际使用的内存
可用pmap查看具体进程pid下的虚拟内存分布情况(低地址到高地址)

虚拟内存对进程而言分为两部分：
1. 用户空间 3GB
2. 内核空间 1GB

#### 用户空间
    
用户能访问的是用户内存空间，用户内存空间地址范围：`0x00000000`至`0xBFFFFFFF`，总容量为3G；

通常情况下，用户只能访问用户空间，但当在执行内陷操作或者系统调用时可以访问内核空间；

##### 进程的内存空间

进程的内存空间按照`访问属性一致的地址空间存放在一起`原则（访问属性指：可读、可写、可执行等）划分为了5个区域；

+ 代码段

    代码段是用来存放可执行文件（二进制文件）的操作指令，可执行程序在内存中的镜像（相当于拷贝了一份运行时的代码）；代码段需要在运行时防止被非法修改，所以是只读段；

+ 数据段

    数据段是用来存放可执行文件中已初始化的全局变量，就是程序中的静态分配的变量和全局变量；

+ BSS段

    BSS段包含了程序中未初始化的全局变量，在内存中BSS段全部置零。

+ 堆 heap

    平时我们所说的堆栈是指栈stack结构，栈stack是类似桶的数据形式，而堆heap则是用`数组`实现的`二叉树`，有兴趣自己去看看，设计很巧妙；
    
    堆是用于存放进程运行中动态分配的内存段，他的大小并不固定，在分配时会动态伸缩；当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；
    
    程序gc时所释放的内存就是释放这里的内存；

+ 栈 stack

    栈是用来存储用户在程序运行时创建的临时变量，也就是函数中的局部变量；栈是后进先出；除此之外，函数在被调用时，其余参数也会被压入调用者的进程栈中，并且到函数返回后，返回值也会被存放回栈中；当函数执行完成后，他们所占用的内存空间会自动释放，栈内存的分配运算内置在处理器的指令集中，效率很高，但是空间有限；

上述的内存区域，代码段、数据段、BSS通常是被连续的存储在内存中，地址上是连续的，而堆和栈会单独存放；堆在靠BSS段，同时地址向上扩展；栈在上方，向下扩展；堆和栈中间是内存映射段，它是高效的I/O映射方式，用于装载一个共享的动态内存库，用户可使用系统接口创建共享内存，做进程间通信；

<div align="center">
    <img src="_media/memstruct.svg">
</div>

#### 内核空间

在`x86 32`位系统里，Linux内核地址空间是指虚拟地址从`0xC0000000`开始到`0xFFFFFFFF`为止的高端内存地址空间，总计1G的容量，包括了内核镜像、物理页面表、驱动程序等运行在内核空间；

### 物理地址

当用户需要使用内存时，就需要将虚拟内存地址映射到物理地址，物理地址就是在内存上的地址；这中间涉及利用`MMU`内存管理单元（Memory Management Unit) 对虚拟地址分段和分页（段页式）地址转换，关于分段和分页的具体流程，这里不详细描述；

## 进程与线程与协程

进程是资源分配的基本单位，线程是调度的基本单位。

在调度层面，线程是调度和分配的基本单位，进程是作为资源分配的基本单位；
在系统资源层面，进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问到他所属的进程的系统资源；进程的资源包括：内存地址空间、文件句柄、文件系统状态、信号处理handler等；线程维护相关的资源，例如：运行栈、调度相关的控制信息、待处理的信号集等；

单进程指单进程单线程模式；单进程单线程并不意味着他只有一个进程，而是只有一个`可控进程`；

最后是协程，它是完全由程序控制的，不受操作系统控制，在调度与创建、销毁成本上，比线程低得多；
以go为例，go协程为2k，线程为1M；在调度切换上，线程切换需要在内核空间中进行完成，而协程完全在用户空间完成；
协程的切换只涉及cpu上下文切换，既一堆寄存器，保存了cpu运行任务所需要的信息；所以协程切换只需要将当前协程的cpu寄存器状态存起来，将要调度的协程cpu寄存器状态加载到cpu寄存器上就行了；
而线程则要做的更多，他需要从用户态切到内核态，同时需要维护线程的运行栈；
用户态切到内核态：进程的内存分为用户内存空间、内核内存空间，这是因为linux设计哲学是：对不同的操作赋予不同的权限，而用户空间无法执行系统调用、中断等，所以当要执行时，需要切换到内核空间进行执行，而这个切换需要现在用户空间保存当前状态，然后内核空间又有个状态，那么就是两个栈了，同时在进入内核空间的时候，内核代码对用户代码不信任，需要进行额外的检测，这些都是性能损耗。