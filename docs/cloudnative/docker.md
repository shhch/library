##  docker

什么是docker？它为什么被所有人推上神坛？它解决了哪些问题？它和k8s的关系是什么？来来来，让我慢慢道来~（文章参考https://time.geekbang.org/column/article/14252 强烈推荐阅读原文）

## docker在容器圈的风云变幻

在早些年呼风唤雨的PaaS浪潮中，PaaS之所以被大家接受的主要原因是它提供了应用托管的功能；

当时虚拟化技术已经十分成熟了，当时的主流用法就是使用一批虚拟机，然后像管理物理机一样，以脚本或者手动部署的方式部署到虚拟机上；这明显无法避免本地环境与部署环境不一致的问题；

而PaaS的托管功能就是为了解决这个问题；在PaaS平台上，你只需要创建好自己的Cloud Foundry项目，然后执行`cf push "我的应用"`命令，就可以将我的本地项目部署到云上了；而像Cloud Foundry这样的PaaS项目，核心组件就是一套应用打包和分发机制；Cloud Foundry为每种主流编程语言都定义了一种打包格式，而“cf push”的作用，基本上等同于用户把应用的可执行文件和启动脚本打进一个压缩包内，上传到云上Cloud Foundry的存储中。接着，Cloud Foundry会通过调度器选择一个可以运行这个应用的虚拟机，然后通知这个机器上的Agent把应用压缩包下载下来启动。

这时候关键来了，由于需要在一个虚拟机上启动很多个来自不同用户的应用，Cloud Foundry会调用操作系统的`Cgroups`和`Namespace`机制为每一个应用单独创建一个称作“沙盒”的隔离环境，然后在“沙盒”中启动这些应用进程。这样，就实现了把多个用户的应用互不干涉地在虚拟机里批量地、自动地运行起来的目的。

而docker做的事情也和这个差不多，也是使用`Cgroups`和`Namespace`机制为每一个应用单独创建一个称作“沙盒”的隔离环境，docker在此基础上只做了一小部分不同的功能；成了docker项目接下来“呼风唤雨”的不二法宝。

这个功能就是docker镜像；这个小小的创新彻底改变了整个云计算领域的发展历程；

上面介绍过的，PaaS之所以能够帮助用户大规模部署应用到集群里，是因为它提供了一套应用打包的功能。可偏偏就是这个打包功能，却成了PaaS日后不断遭到用户诟病的一个“软肋”。出现这个问题的根本原因是，一旦用上了PaaS，用户就必须为每种语言、每种框架，甚至每个版本的应用维护一个打好的包。这个打包过程，没有任何章法可循，更麻烦的是，明明在本地运行得好好的应用，却需要做很多修改和配置工作才能在PaaS里运行起来。而这些修改和配置，并没有什么经验可以借鉴，基本上得靠不断试错，直到你摸清楚了本地应用和远端PaaS匹配的“脾气”才能够搞定。最后结局就是，“cf push”确实是能一键部署了，但是为了实现这个一键部署，用户为每个应用打包的工作可谓一波三折，费尽心机。

而docker镜像，就彻底解决了这个问题；所谓docker镜像包，就是在PaaS的应用文件 + 启动脚本的基础上，额外把应用所需的操作系统（包含所需的目录和文件）给打包进去了；所以docker镜像包就和你在本地运行的项目 + 环境一模一样；有了docker镜像包后，就不需要再做任何额外的处理，就能部署起来，他带来的能力是：**本地环境与云端环境高度一致**；

有了docker之后，PaaS平台所提供的功能完全没了用武之地，而用户最抓狂的打包过程也消失了，代价则是唾手可得的各种操作系统目录与文件；而对于开发者们来说，在终于体验到了生产力解放所带来的痛快之后，他们自然选择了用脚投票，直接宣告了PaaS时代的结束。

## docker镜像构建的原理与实现

docker的核心在于构建一个进程的沙盒，通过各种约束条件，给这个沙盒制造边界来对进程所使用的资源进行限制；对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。

### Namespace

当我们执行一个`docker run -it busybox /bin/sh`命令时，busybox为自己创建的镜像，run表示运行一个镜像，-it表示以交互模式运行容器并指定一个伪输入终端/bin/sh；上面这条指令翻译成人类的语言就是：请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互。

如果这个时候执行一条ps命令，就会发现，里面只有两个进程，同时/bin/sh的PID是1，而你执行`exit`命令退出后，再ps，会发现与docker中的完全不同；这意味着刚刚运行的容器已经被docker隔离在了与主机环境完全不同的世界中；

正常情况下，当我们运行/bin/sh时，系统会分配一个进程编号即PID，这是一个进程的唯一编号，而PID=1的进程一般是系统最开始的进程（主机上一般为init进程或systemd进程）；而容器内的进程在启动时，docker会用个障眼法，让容器内的进程看不到其他进程，就误以为自己是1号进程；这种机制就是对被隔离的进程的进程空间做手脚，使得这些进程只能看到重新计算过的进程编号，比如PID=1。可实际上，他们在宿主机的操作系统里，还是原来的正常分配的进程PID；这个技术就是linux中的`Namespace`机制；

Namespace的使用方式也只是在linux创建新进程的时候的一个可选参数，linux下创建进程的系统调用是clone()，它会创建一个新的进程并返回他的pid
```
int pid = clone(main_function, stack_size, SIGCHLD, NULL); 
```

而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：
```
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
```
那么这个新创建的进程就会看到一个`全新`的进程空间，在这个进程空间里，它的PID是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的PID还是真实的数值，比如100。

而除了我们刚刚用到的PID Namespace，Linux操作系统还提供了`Mount、UTS、IPC、Network和User`这些Namespace，用来对各种不同的进程上下文进行“障眼法”操作。

比如，Mount Namespace，用于让被隔离进程只看到当前Namespace里的挂载点信息；
Network Namespace，用于让被隔离进程看到当前Namespace里的网络设备和配置。

### Cgroups

通过namespace确实能够实现隔离，但是只是在可见性上做了隔离，它还是和其他容器一样运行在一个linux系统下；这意味着，他们共同使用者系统的资源（cpu、内存、磁盘等），那么就会存在某些容器抢占了大量的系统资源，或者他需要资源被其他容器抢占；

linux的Cgroups是实现隔离的另一个重要手段，这是linux内核为进程设置资源限制的功能；
