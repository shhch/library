## TCP/IP网络模型

计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）

TCP/IP是互联网相关协议的总称，例如：tcp、ip、udp、ftp、http、icmp、smtp等都属于TCP/IP族内的协议；

TCP/IP模型是互联网的基础，他是一系列协议的总称；这些协议可以划分为四层；还有更为细致的OSI模型，划分为了7层；

+ 链路层：负责封装和解封装IP报文，发送和接受ARP和RARP报文等；
+ 网络层：负责路由选择以及把报文发送到目标网络或主机；
+ 传输层：负责对报文进行分组和重组，并以tcp或udp协议格式封装报文；
+ 应用层；负责向用户提供应用程序，例如http，ftp，dns等；

在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。

### UDP协议

UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

1. 面向无连接
    首先udp不像tcp一样，需要进行三次握手和四次挥手，那么意味着，他想发数据就可以直接发了，不管你有没有准备好，他只是数据报文的搬运工，不会对报文进行任何拆分和拼接工作；具体来说就这两点：
    + 在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了
    + 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作

2. 有单播、多播、广播的功能
    UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。

3. UDP是面向报文的
    发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。

4. 不可靠性
    首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
    并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。
    再者网络环境时好时坏，但是UDP因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用UDP而不是TCP。

5. 头部开销小，传输数据报文时是很高效的。
    UDP头部包含了以下几个数据块，都是16位（2字节）：
    + 两个16位的端口号，分别为源端口与目标端口
    + 整个数据报文的长度
    + 整个数据报文的校验和，该字段用于发现头部信息和数据中的错误

因此，UDP的头部开销很小，只有8字节，相比TCP至少20多字节要少的多，所以在传输时是很高效的，损失的带宽少；

<div align="center">
    <img src="_media/udp.gif">
</div>

### TCP协议

当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。

TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP是面向连接的、可靠的流协议。

<div align="center">
    <img src="_media/TCP status.svg">
</div>

#### TCP连接

TCP连接需要进行三次传输进行连接
1. 第一次传输：客户端随机生成初始序列号SYN并发送，之后进入SYN-SEND状态；
2. 服务端收到后，如果同意，则回复SYN与ACK，并进入SYN-RECEIVED状态；服务端本身会维护两个连接队列，分别是半连接队列和已连接队列，当服务端首次收到客户端连接请求时，将其进入到待确认队列（客户端状态为SYN_RCVD），然后回复客户端；如果队列已满，则会拒绝连接；回复的时候服务端还会带上自己的窗口大小，客户端通过这次的回复来设置客户端初次的滑动窗口大小
3. 客户端收到服务端回复后，需要再次向服务段发送一个确认报文，表示收到了服务端的回复；服务端接受到改回复后会将此连接从半连接队列转移到已连接队列，双端状态都为ESTABLISHED，此时连接已建立完成

#### TCP断开连接与TIME_WAIT状态

关闭连接的操作就是告诉对方，已经没有数据需要传输，可以结束，但仍然保留了接收的数据的能力；整个关闭状态如下：
1. 当客户端没有待发送的数据时，它会向服务端发送FIN消息，发送消息后会进入FIN_WAIT_1状态；
2. 服务端接收到客户端的FIN消息后，会进入CLOSE_WAIT状态并向客户端发送ACK消息，客户端接收到ACK消息时会进入FIN_WAIT_2状态；
3. 当服务端没有待发送的数据时，服务端会向客户端发送 FIN 消息；
4. 客户端接收到FIN消息后，会进入TIME_WAIT状态并向服务端发送ACK消息，服务端收到后会进入CLOSED状态；
5. 客户端等待两个MSL最大数据段生命周期(Maximum segment lifetime，MSL)的时间后也会进入CLOSED状态；

在TCP连接中，TIME_WAIT的是为了处理某种异常下一个状态，由TCP连接状态图和流程可以看出在双方关闭TCP连接时触发TIME_WAIT状态，同时TIME_WAIT只在主动发起连接的一方出现，也就是客户端，服务端断开连接后会进入CLOSED状态;

连接方需要等待两个MSL后才进入CLOSED状态有以下两个原因：
+ 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的TCP连接收到
+ 保证TCP连接的远程被正确关闭，即等待被动关闭连接的一方收到FIN对应的ACK消息

针对这两点进行分析：
1. 阻止延迟数据段发生
    每个TCP数据段都包含唯一的序列号来进行标识，当关闭时的SEQ因为延迟，接收方没有收到就关闭连接了，下一个同源tcp连接后才接收到，就会导致异常发生

2. 保证连接正确关闭
    如果客户端的等待时间不够，当服务端没有收到ACK时，客户端重新发起了同源TCP连接，此时服务端会认为连接是合法的，所以当新客户端发起SYN时，会被服务端回复RST拒绝，导致连接失败终止；等待时间内如果服务端没收到ACK会重新发起FIN到客户端进行重试来保证连接关闭

## HTTPS协议

### 密码学基础
在正式讲解HTTPS协议之前，我们首先要知道一些密码学的知识。

+ 明文： 明文指的是未被加密过的原始数据。
+ 密文：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。
+ 密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。

+ 对称加密：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。<br>
    其加密过程如下：明文 + 加密算法 + 私钥 => 密文<br>
    解密过程如下： 密文 + 解密算法 + 私钥 => 明文<br>

    对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。<br>
    其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。

+ 非对称加密：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。<br>
    被公钥加密过的密文只能被私钥解密，过程如下：<br>
    明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文<br>
    被私钥加密过的密文只能被公钥解密，过程如下：<br>
    明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文

    由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。
    非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
    在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。

### HTTPS通信过程

HTTPS协议 = HTTP协议 + SSL协议/TLS协议，在https协议传输数据的时候，需要使用ssl/tls协议对数据进行加密和解密，然后使用http协议进行加密后的数据进行传输；

SSL协议全称Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0；

TLS协议全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。

HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口

2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3. 服务器将自己的公钥发送给客户端。

4. 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

7. 然后服务器将加密后的密文发送给客户端。

8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

其中证书包含：证书版本、序列号、加密算法、签名算法、公钥、有效期与使用者的详细信息；

签名的过程：证书中包含签名算法，这一般是个hash，在对原数据进行加密前，先用签名算法算得hash值也就是签名，将其拼接到原数据后，并同原数据一起使用公钥进行加密传输；

签名验证：在服务端收到加密的数据后，通过私钥解密，得到原数据与签名，然后对原数据进行签名验证，既用签名算法获取签名，然后与客户端传过来的签名进行匹配，既可知道数据是否发生篡改；
